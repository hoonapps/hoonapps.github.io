---
title: "What are Generics?"
date: 2024-12-01 00:00:00 +0900
categories: [Typescript]
tags: [generics, Typescript, Nestjs, Passport.js]
image: 
---


# Introduction

In this post, I will dive deeper into generics and explore them further.

Let's begin!

---

## What is generics

Generics are a powerful feature in TypeScript that allows you to define reusable components that work with a variety of data types.
Instead of specifying concrete data types, generics use type parameters that are defined at the time of use.
They provide a way to tell functions, classes, or interfaces what type you want to use when you call it.


### Why use generics?

1. Code Reusability
2. Type Safety
3. Flexibility

### Usage of Generic Functions

```typescript
function identity<T>(value: T): T{
    return value;
}

//example
const result1 = identity<string>("Hello"); // result1 = "Hello"
const result2 = identity<number>(1); // result2 = 1
```

By adding `T` (a type parameter) to the `identity` function, it can support various types while maintaining type safety.
If the input value is a `string`, the return value must also be a `string`.

```typescript
function stringIdentity(value: string): string {
    return value;
}

function numberIdentity(value: number): number {
    return value;
}
```
If you don't use generics, you would need to create two separate functions to ensure type safety, as shown above.
Generics help eliminate this unnecessary repetition, which is one of their biggest advantages.

<!-- ë§Œì•½ ì œë„¤ë¦­ì„ ì‚¬ìš©í•˜ì§€ì•Šê³  íƒ€ì…ì„ ë³´ì¥ë°›ìœ¼ë ¤ë©´ ìœ„ ì²˜ëŸ¼ í•¨ìˆ˜ 2ê°œë¥¼ ë§Œë“¤ì–´ì•¼í•©ë‹ˆë‹¤.
ì´ëŠ” ë¶ˆí”¼ìš”í•œ ë°˜ë³µì„ ì¤„ìš”ì£¼ê¸° ë•Œë¬¸ì— ê°€ì¥ í° ì¥ì ì…ë‹ˆë‹¤. -->

### ì‹¤ì œ nestjs í”„ë¡œì íŠ¸ ì˜ˆì œ

```typescript
export declare function PassportStrategy<T extends Type<any> = any>(Strategy: T, name?: string | undefined, callbackArity?: true | number): {
    new (...args: any[]): InstanceType<T>;
};
```

<!-- ìœ„ëŠ” PassportStrategy ì œë„¤ë¦­ í•¨ìˆ˜ì…ë‹ˆë‹¤.
NestJSì™€ Passport.jsë¥¼ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ, PassportStrategyëŠ” Passport.js ì¸ì¦ ì „ëµ í´ë˜ìŠ¤ë¥¼ ì‰½ê²Œ í™•ì¥í•  ìˆ˜ ìˆë„ë¡ ë•ëŠ” ìœ í‹¸ë¦¬í‹°ì…ë‹ˆë‹¤. -->
The code above represents the PassportStrategy generic function.
When using NestJS with Passport.js, PassportStrategy is a utility that simplifies extending Passport.js authentication strategy classes.


#### Code Explanation
`<T extends Type<any> = any>`

- Ensures the type is a class type with a constructor.
- Defaults to any if not explicitly specified.

`Strategy: T`

- Strategy is a parameter that takes an authentication strategy class.
- Typically used with classes like JwtStrategy or LocalStrategy.

`name?: string | undefined`

- name is an optional parameter that specifies the name of the authentication strategy.

`callbackArity?: true | number`

- callbackArity is an optional parameter to set the number of callback arguments.
- true uses the default value, while a number specifies the exact count.

`new (...args: any[]): InstanceType<T>`

- The return value is a class constructor.
- InstanceType<T>: Represents the instance type created from the class T.

<!-- #### ì½”ë“œ ì„¤ëª…
1. <T extends Type<any> = any>
- ìƒì„±ìë¥¼ ê°€ì§€ëŠ” í´ë˜ìŠ¤ íƒ€ì…ì„ì„ ë³´ì¥í•©ë‹ˆë‹¤.
- ëª…ì‹œí•˜ì§€ ì•Šì„ì‹œ ê¸°ë³¸ê°’ì€ anyì…ë‹ˆë‹¤. 
2. Strategy: T
- StrategyëŠ” ì¸ì¦ì „ëµí´ë˜ìŠ¤ë¥¼ ë°›ëŠ” ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤.
-  ì£¼ë¡œ `JwtStrategy`, `LocalStrategy` ë“±ì˜ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
3. name?: string | undefined
- nameì€ ì¸ì¦ ì „ëµì˜ ì´ë¦„ì„ ë°›ëŠ” ì˜µì…”ë„ ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤.
4. callbackArity?: true | number
- callbackArityëŠ” ì½œë°± ë§¤ê°œë³€ìˆ˜ ê°œìˆ˜ë¥¼ ì„¤ì •í•˜ëŠ” ì˜µì…”ë„ ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤.
- trueëŠ” ê¸°ë³¸ê°’, numberëŠ” ì½œë°± ê°œìˆ˜
5. new (...args: any[]): InstanceType<T>
- ë°˜í™˜ê°’ì´ë©° í´ë˜ìŠ¤ ìƒì„±ìë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
- InstanceType<T>: T íƒ€ì…ì˜ í´ë˜ìŠ¤ì—ì„œ ìƒì„±ëœ ì¸ìŠ¤í„´ìŠ¤ íƒ€ì…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. -->



#### Usage Example (JwtStrategy, LocalStrategy)

```typescript
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, ExtractJwt } from 'passport-jwt';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: 'mySecretKey',
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}
```

```typescript
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { Injectable } from '@nestjs/common';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy, 'local') {
  constructor() {
    super({
      usernameField: 'email', // Override default 'username' field
      passwordField: 'password',
    });
  }

  async validate(email: string, password: string): Promise<any> {
    // Implement custom user validation logic
    const user = { email, id: 1 }; // Example user
    if (!user) {
      throw new Error('Invalid credentials');
    }
    return user;
  }
}
```

# Conclusion

Today, I studied the reasons for using generic functions, how to use them, and some practical examples.
I wrote this post to refresh my memory of what I learned in the past while studying.
I hope this is helpful for you as well!

<!-- ì˜¤ëŠ˜ì€ ì œë„¤ë¦­ í•¨ìˆ˜ì˜ ì‚¬ìš©ì´ìœ , ì‚¬ìš©ë²•, ì‹¤ì œì˜ˆì œë¥¼ ê³µë¶€í•´ë´¤ë‹¤.
ì˜ˆì „ì— ê³µë¶€í•˜ë©´ì„œ ë°°ìš´ê²ƒì„ ë‹¤ì‹œ ê¸°ì–µí•˜ê¸° ìœ„í•´ í¬ìŠ¤íŠ¸ë¥¼ ì ì—ˆìŠµë‹ˆë‹¤.
ì—¬ëŸ¬ë¶„ì—ê²Œë„ ë„ì›€ì´ ëìœ¼ë©´ ì¢‹ê² ìŠµë‹ˆë‹¤. -->

Thank you for reading, and happy blogging! ğŸš€

## References

- [https://learn.microsoft.com/en-us/training/modules/typescript-generics/2-what-are-generics](https://learn.microsoft.com/en-us/training/modules/typescript-generics/2-what-are-generics)
- [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)


